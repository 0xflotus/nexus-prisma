/**
 * This file is automatically generated. Do not make changes directly.
 * 
 * By default this will regenerate when the server is started 
 * and NODE_ENV !== "production".
 * 
 * Mostly for internal use by GQLiteral unless otherwise 
 * documented / subject to change.
 * 
 * If you want more configurable types to use elsewhere, look into one of:
 *
 * https://github.com/dotansimha/graphql-code-generator
 * https://github.com/prisma/graphqlgen
 * https://github.com/apollographql/apollo-tooling
 */
import * as prisma from "./prisma-client/index"
import * as ctx from "./../context"

// Maybe Promise
type MP<T> = T | PromiseLike<T>;

// Maybe Promise List
type MPL<T> = MP<T>[];

// Maybe Thunk
type MT<T> = T | (() => T);

// Maybe Thunk, with args
type MTA<T, A> = T | ((args?: A) => T);

export type QueryUserReturnType = MP<null | UserReturnType>;

export interface QueryUserArgs {
  where?: UserWhereUniqueInput;
}

export type QueryUsersReturnType = MP<MPL<MP<UserReturnType>>>;

export interface QueryUsersArgs {
  first?: number;
  last?: number;
}

export interface QueryRootType {
  user?: null | any;
  users: any[];
}

export type QueryReturnType = {
  user?: MTA<MP<null | any>, QueryUserArgs>;
  users: MTA<MP<any[]>, QueryUsersArgs>;
}

interface UserWhereUniqueInput {
  id?: string;
}

export type UserBlogPostsReturnType = MP<MPL<MP<PostReturnType>>>;

export interface UserBlogPostsArgs {
  after?: string;
  before?: string;
  first?: number;
  last?: number;
  orderBy?: PostOrderByInput;
  skip?: number;
  where?: PostWhereInput;
}

export type UserIdReturnType = MP<string>;

export type UserNameReturnType = MP<string>;

export type UserRootType = prisma.User;

export type UserReturnType = prisma.User

export type PostOrderByInput = "content_ASC" | "content_DESC" | "createdAt_ASC" | "createdAt_DESC" | "id_ASC" | "id_DESC" | "title_ASC" | "title_DESC" | "updatedAt_ASC" | "updatedAt_DESC";

interface PostWhereInput {
  AND?: Array<null | PostWhereInput>;
  comments_every?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  content?: string;
  content_contains?: string;
  content_ends_with?: string;
  content_gt?: string;
  content_gte?: string;
  content_in?: Array<null | string>;
  content_lt?: string;
  content_lte?: string;
  content_not?: string;
  content_not_contains?: string;
  content_not_ends_with?: string;
  content_not_in?: Array<null | string>;
  content_not_starts_with?: string;
  content_starts_with?: string;
  id?: string;
  id_contains?: string;
  id_ends_with?: string;
  id_gt?: string;
  id_gte?: string;
  id_in?: Array<null | string>;
  id_lt?: string;
  id_lte?: string;
  id_not?: string;
  id_not_contains?: string;
  id_not_ends_with?: string;
  id_not_in?: Array<null | string>;
  id_not_starts_with?: string;
  id_starts_with?: string;
  NOT?: Array<null | PostWhereInput>;
  OR?: Array<null | PostWhereInput>;
  title?: string;
  title_contains?: string;
  title_ends_with?: string;
  title_gt?: string;
  title_gte?: string;
  title_in?: Array<null | string>;
  title_lt?: string;
  title_lte?: string;
  title_not?: string;
  title_not_contains?: string;
  title_not_ends_with?: string;
  title_not_in?: Array<null | string>;
  title_not_starts_with?: string;
  title_starts_with?: string;
}

interface CommentWhereInput {
  AND?: Array<null | CommentWhereInput>;
  content?: string;
  content_contains?: string;
  content_ends_with?: string;
  content_gt?: string;
  content_gte?: string;
  content_in?: Array<null | string>;
  content_lt?: string;
  content_lte?: string;
  content_not?: string;
  content_not_contains?: string;
  content_not_ends_with?: string;
  content_not_in?: Array<null | string>;
  content_not_starts_with?: string;
  content_starts_with?: string;
  id?: string;
  id_contains?: string;
  id_ends_with?: string;
  id_gt?: string;
  id_gte?: string;
  id_in?: Array<null | string>;
  id_lt?: string;
  id_lte?: string;
  id_not?: string;
  id_not_contains?: string;
  id_not_ends_with?: string;
  id_not_in?: Array<null | string>;
  id_not_starts_with?: string;
  id_starts_with?: string;
  NOT?: Array<null | CommentWhereInput>;
  OR?: Array<null | CommentWhereInput>;
}

export type PostCommentsReturnType = MP<MPL<MP<CommentReturnType>>>;

export interface PostCommentsArgs {
  after?: string;
  before?: string;
  first?: number;
  last?: number;
  orderBy?: CommentOrderByInput;
  skip?: number;
  where?: CommentWhereInput;
}

export type PostContentReturnType = MP<string>;

export type PostIdReturnType = MP<string>;

export type PostTitleReturnType = MP<string>;

export interface PostRootType {
  comments: any[];
  content: string;
  id: string;
  title: string;
}

export type PostReturnType = {
  comments: MTA<MP<any[]>, PostCommentsArgs>;
  content: MT<MP<string>>;
  id: MT<MP<string>>;
  title: MT<MP<string>>;
}

export type CommentOrderByInput = "content_ASC" | "content_DESC" | "createdAt_ASC" | "createdAt_DESC" | "id_ASC" | "id_DESC" | "updatedAt_ASC" | "updatedAt_DESC";

export type CommentContentReturnType = MP<string>;

export type CommentIdReturnType = MP<string>;

export interface CommentRootType {
  content: string;
  id: string;
}

export type CommentReturnType = {
  content: MT<MP<string>>;
  id: MT<MP<string>>;
}

export interface GQLiteralGenArgTypes {
  Query: {
    user: QueryUserArgs;
    users: QueryUsersArgs;
  };
  User: {
    blogPosts: UserBlogPostsArgs;
  };
  Post: {
    comments: PostCommentsArgs;
  };
}

export interface GQLiteralGenRootTypes {
  Query: QueryRootType;
  User: UserRootType;
  Post: PostRootType;
  Comment: CommentRootType;
}

export interface GQLiteralGenReturnTypes {
  Query: {
    user: QueryUserReturnType;
    users: QueryUsersReturnType;
  };
  User: {
    blogPosts: UserBlogPostsReturnType;
    id: UserIdReturnType;
    name: UserNameReturnType;
  };
  Post: {
    comments: PostCommentsReturnType;
    content: PostContentReturnType;
    id: PostIdReturnType;
    title: PostTitleReturnType;
  };
  Comment: {
    content: CommentContentReturnType;
    id: CommentIdReturnType;
  };
}

export interface GQLiteralGenTypes {
  argTypes: GQLiteralGenArgTypes;
  rootTypes: GQLiteralGenRootTypes;
  returnTypes: GQLiteralGenReturnTypes;
  context: ctx.Context;
  enums: {
    PostOrderByInput: PostOrderByInput;
    CommentOrderByInput: CommentOrderByInput;
  };
  objects: {
    Query: QueryRootType;
    User: UserRootType;
    Post: PostRootType;
    Comment: CommentRootType;
  };
  interfaces: {};
  unions: {};
  scalars: {
    ID: any;
    String: any;
    Int: any;
    Boolean: any;
  };
  inputObjects: {
    UserWhereUniqueInput: any;
    PostWhereInput: any;
    CommentWhereInput: any;
  };
  allInputTypes: 
    | Extract<keyof GQLiteralGenTypes['inputObjects'], string>
    | Extract<keyof GQLiteralGenTypes['enums'], string>
    | Extract<keyof GQLiteralGenTypes['scalars'], string>;
  allOutputTypes: 
    | Extract<keyof GQLiteralGenTypes['objects'], string>
    | Extract<keyof GQLiteralGenTypes['enums'], string>
    | Extract<keyof GQLiteralGenTypes['unions'], string>
    | Extract<keyof GQLiteralGenTypes['interfaces'], string>
    | Extract<keyof GQLiteralGenTypes['scalars'], string>;
}

export type Gen = GQLiteralGenTypes;

declare global {
  interface GQLiteralGen extends GQLiteralGenTypes {}
}
