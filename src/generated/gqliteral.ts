/**
 * This file is automatically generated. Do not make changes directly.
 * 
 * By default this will regenerate when the server is started 
 * and NODE_ENV !== "production".
 * 
 * Mostly for internal use by GQLiteral unless otherwise 
 * documented / subject to change.
 * 
 * If you want more configurable types to use elsewhere, look into one of:
 *
 * https://github.com/dotansimha/graphql-code-generator
 * https://github.com/prisma/graphqlgen
 * https://github.com/apollographql/apollo-tooling
 */
import * as prisma from "./prisma-client/index"
import * as ctx from "./../context"

// Maybe Promise
type MP<T> = T | PromiseLike<T>;

// Maybe Promise List
type MPL<T> = MP<T>[];

// Maybe Thunk
type MT<T> = T | (() => T);

// Maybe Thunk, with args
type MTA<T, A> = T | ((args?: A) => T);

export type QueryBlogPostsReturnType = MP<MPL<MP<PostReturnType>>>;

export interface QueryBlogPostsArgs {
  where?: PostWhereInput;
}

export type QueryUserReturnType = MP<null | UserReturnType>;

export interface QueryUserArgs {
  where?: UserWhereUniqueInput;
}

export type QueryUsersReturnType = MP<MPL<MP<UserReturnType>>>;

export interface QueryUsersArgs {
  where?: UserWhereInput;
}

export interface QueryRootType {
  blogPosts: any[];
  user?: null | any;
  users: any[];
}

export type QueryReturnType = {
  blogPosts: MTA<MP<any[]>, QueryBlogPostsArgs>;
  user?: MTA<MP<null | any>, QueryUserArgs>;
  users: MTA<MP<any[]>, QueryUsersArgs>;
}

interface PostWhereInput {
  AND?: Array<null | PostWhereInput>;
  comments_every?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  content?: string;
  content_contains?: string;
  content_ends_with?: string;
  content_gt?: string;
  content_gte?: string;
  content_in?: Array<null | string>;
  content_lt?: string;
  content_lte?: string;
  content_not?: string;
  content_not_contains?: string;
  content_not_ends_with?: string;
  content_not_in?: Array<null | string>;
  content_not_starts_with?: string;
  content_starts_with?: string;
  id?: string;
  id_contains?: string;
  id_ends_with?: string;
  id_gt?: string;
  id_gte?: string;
  id_in?: Array<null | string>;
  id_lt?: string;
  id_lte?: string;
  id_not?: string;
  id_not_contains?: string;
  id_not_ends_with?: string;
  id_not_in?: Array<null | string>;
  id_not_starts_with?: string;
  id_starts_with?: string;
  NOT?: Array<null | PostWhereInput>;
  OR?: Array<null | PostWhereInput>;
  title?: string;
  title_contains?: string;
  title_ends_with?: string;
  title_gt?: string;
  title_gte?: string;
  title_in?: Array<null | string>;
  title_lt?: string;
  title_lte?: string;
  title_not?: string;
  title_not_contains?: string;
  title_not_ends_with?: string;
  title_not_in?: Array<null | string>;
  title_not_starts_with?: string;
  title_starts_with?: string;
}

interface CommentWhereInput {
  AND?: Array<null | CommentWhereInput>;
  content?: string;
  content_contains?: string;
  content_ends_with?: string;
  content_gt?: string;
  content_gte?: string;
  content_in?: Array<null | string>;
  content_lt?: string;
  content_lte?: string;
  content_not?: string;
  content_not_contains?: string;
  content_not_ends_with?: string;
  content_not_in?: Array<null | string>;
  content_not_starts_with?: string;
  content_starts_with?: string;
  id?: string;
  id_contains?: string;
  id_ends_with?: string;
  id_gt?: string;
  id_gte?: string;
  id_in?: Array<null | string>;
  id_lt?: string;
  id_lte?: string;
  id_not?: string;
  id_not_contains?: string;
  id_not_ends_with?: string;
  id_not_in?: Array<null | string>;
  id_not_starts_with?: string;
  id_starts_with?: string;
  NOT?: Array<null | CommentWhereInput>;
  OR?: Array<null | CommentWhereInput>;
}

export type PostContentReturnType = MP<string>;

export type PostIdReturnType = MP<string>;

export type PostTitleReturnType = MP<string>;

export interface PostRootType {
  content: string;
  id: string;
  title: string;
}

export type PostReturnType = {
  content: MT<MP<string>>;
  id: MT<MP<string>>;
  title: MT<MP<string>>;
}

interface UserWhereUniqueInput {
  id?: string;
}

export type UserIdentifierReturnType = MP<string>;

export type UserNameReturnType = MP<string>;

export type UserRootType = prisma.User;

export type UserReturnType = prisma.User

interface UserWhereInput {
  AND?: Array<null | UserWhereInput>;
  id?: string;
  id_contains?: string;
  id_ends_with?: string;
  id_gt?: string;
  id_gte?: string;
  id_in?: Array<null | string>;
  id_lt?: string;
  id_lte?: string;
  id_not?: string;
  id_not_contains?: string;
  id_not_ends_with?: string;
  id_not_in?: Array<null | string>;
  id_not_starts_with?: string;
  id_starts_with?: string;
  name?: string;
  name_contains?: string;
  name_ends_with?: string;
  name_gt?: string;
  name_gte?: string;
  name_in?: Array<null | string>;
  name_lt?: string;
  name_lte?: string;
  name_not?: string;
  name_not_contains?: string;
  name_not_ends_with?: string;
  name_not_in?: Array<null | string>;
  name_not_starts_with?: string;
  name_starts_with?: string;
  NOT?: Array<null | UserWhereInput>;
  OR?: Array<null | UserWhereInput>;
  posts_every?: PostWhereInput;
  posts_none?: PostWhereInput;
  posts_some?: PostWhereInput;
}

export interface GQLiteralGenArgTypes {
  Query: {
    blogPosts: QueryBlogPostsArgs;
    user: QueryUserArgs;
    users: QueryUsersArgs;
  };
}

export interface GQLiteralGenRootTypes {
  Query: QueryRootType;
  Post: PostRootType;
  User: UserRootType;
}

export interface GQLiteralGenReturnTypes {
  Query: {
    blogPosts: QueryBlogPostsReturnType;
    user: QueryUserReturnType;
    users: QueryUsersReturnType;
  };
  Post: {
    content: PostContentReturnType;
    id: PostIdReturnType;
    title: PostTitleReturnType;
  };
  User: {
    identifier: UserIdentifierReturnType;
    name: UserNameReturnType;
  };
}

export interface GQLiteralGenTypes {
  argTypes: GQLiteralGenArgTypes;
  rootTypes: GQLiteralGenRootTypes;
  returnTypes: GQLiteralGenReturnTypes;
  context: ctx.Context;
  enums: {};
  objects: {
    Query: QueryRootType;
    Post: PostRootType;
    User: UserRootType;
  };
  interfaces: {};
  unions: {};
  scalars: {
    String: any;
    ID: any;
    Boolean: any;
  };
  inputObjects: {
    PostWhereInput: any;
    CommentWhereInput: any;
    UserWhereUniqueInput: any;
    UserWhereInput: any;
  };
  allInputTypes: 
    | Extract<keyof GQLiteralGenTypes['inputObjects'], string>
    | Extract<keyof GQLiteralGenTypes['enums'], string>
    | Extract<keyof GQLiteralGenTypes['scalars'], string>;
  allOutputTypes: 
    | Extract<keyof GQLiteralGenTypes['objects'], string>
    | Extract<keyof GQLiteralGenTypes['enums'], string>
    | Extract<keyof GQLiteralGenTypes['unions'], string>
    | Extract<keyof GQLiteralGenTypes['interfaces'], string>
    | Extract<keyof GQLiteralGenTypes['scalars'], string>;
}

export type Gen = GQLiteralGenTypes;

declare global {
  interface GQLiteralGen extends GQLiteralGenTypes {}
}
