// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`integrates together: graphql schema 1`] = `
"### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


type A {
  hash: String!
  id: Int!
}

type Query {
  ok: Boolean!
}
"
`;

exports[`integrates together: nexus core typegen 1`] = `
"/**
 * This file was automatically generated by GraphQL Nexus
 * Do not make changes to this file directly
 */





declare global {
  interface NexusGenCustomOutputProperties<TypeName extends string> {
    crud: NexusPrisma<TypeName, 'crud'>
    model: NexusPrisma<TypeName, 'model'>
  }
}

declare global {
  interface NexusGen extends NexusGenTypes {}
}

export interface NexusGenInputs {
}

export interface NexusGenEnums {
}

export interface NexusGenRootTypes {
  A: { // root type
    hash: string; // String!
    id: number; // Int!
  }
  Query: {};
  String: string;
  Int: number;
  Float: number;
  Boolean: boolean;
  ID: string;
}

export interface NexusGenAllTypes extends NexusGenRootTypes {
}

export interface NexusGenFieldTypes {
  A: { // field return type
    hash: string; // String!
    id: number; // Int!
  }
  Query: { // field return type
    ok: boolean; // Boolean!
  }
}

export interface NexusGenArgTypes {
}

export interface NexusGenAbstractResolveReturnTypes {
}

export interface NexusGenInheritedFields {}

export type NexusGenObjectNames = \\"A\\" | \\"Query\\";

export type NexusGenInputNames = never;

export type NexusGenEnumNames = never;

export type NexusGenInterfaceNames = never;

export type NexusGenScalarNames = \\"Boolean\\" | \\"Float\\" | \\"ID\\" | \\"Int\\" | \\"String\\";

export type NexusGenUnionNames = never;

export interface NexusGenTypes {
  context: any;
  inputTypes: NexusGenInputs;
  rootTypes: NexusGenRootTypes;
  argTypes: NexusGenArgTypes;
  fieldTypes: NexusGenFieldTypes;
  allTypes: NexusGenAllTypes;
  inheritedFields: NexusGenInheritedFields;
  objectNames: NexusGenObjectNames;
  inputNames: NexusGenInputNames;
  enumNames: NexusGenEnumNames;
  interfaceNames: NexusGenInterfaceNames;
  scalarNames: NexusGenScalarNames;
  unionNames: NexusGenUnionNames;
  allInputTypes: NexusGenTypes['inputNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['scalarNames'];
  allOutputTypes: NexusGenTypes['objectNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['unionNames'] | NexusGenTypes['interfaceNames'] | NexusGenTypes['scalarNames'];
  allNamedTypes: NexusGenTypes['allInputTypes'] | NexusGenTypes['allOutputTypes']
  abstractTypes: NexusGenTypes['interfaceNames'] | NexusGenTypes['unionNames'];
  abstractResolveReturn: NexusGenAbstractResolveReturnTypes;
}"
`;

exports[`integrates together: nexus prisma typegen 1`] = `
"import * as photon from '@generated/photon';
import { core } from 'nexus';
// Types helpers
  type ModelNameExistsInGraphQLType<
  ReturnType extends any
> = ReturnType extends core.GetGen<'objectNames'> ? true : false;

type NexusPrismaScalarOpts = {
  alias?: string;
};

type Pagination = {
  first?: boolean;
  last?: boolean;
  before?: boolean;
  after?: boolean;
  skip?: boolean;
};

type RootObjectTypes = Pick<
  core.GetGen<'rootTypes'>,
  core.GetGen<'objectNames'>
>;

type IsSubset<A, B> = keyof A extends never
  ? false
  : B extends A
  ? true
  : false;

type OmitByValue<T, ValueType> = Pick<
  T,
  { [Key in keyof T]: T[Key] extends ValueType ? never : Key }[keyof T]
>;

type GetSubsetTypes<ModelName extends any> = keyof OmitByValue<
  {
    [P in keyof RootObjectTypes]: ModelName extends keyof ModelTypes
      ? IsSubset<RootObjectTypes[P], ModelTypes[ModelName]> extends true
        ? RootObjectTypes[P]
        : never
      : never;
  },
  never
>;

type SubsetTypes<ModelName extends any> = GetSubsetTypes<
  ModelName
> extends never
  ? \`ERROR: No subset types are available. Please make sure that one of your GraphQL type is a subset of your t.model('<ModelName>')\`
  : GetSubsetTypes<ModelName>;

type DynamicRequiredType<ReturnType extends any> = ModelNameExistsInGraphQLType<
  ReturnType
> extends true
  ? { type?: SubsetTypes<ReturnType> }
  : { type: SubsetTypes<ReturnType> };

type GetNexusPrismaInput<
  ModelName extends any,
  MethodName extends any,
  InputName extends 'filtering' | 'ordering'
> = ModelName extends keyof NexusPrismaInputs
  ? MethodName extends keyof NexusPrismaInputs[ModelName]
    ? NexusPrismaInputs[ModelName][MethodName][InputName]
    : never
  : never;

type NexusPrismaRelationOpts<
  ModelName extends any,
  MethodName extends any,
  ReturnType extends any
> = GetNexusPrismaInput<
  // If GetNexusPrismaInput returns never, it means there are no filtering/ordering args for it. So just use \`alias\` and \`type\`
  ModelName,
  MethodName,
  'filtering'
> extends never
  ? {
      alias?: string;
    } & DynamicRequiredType<ReturnType>
  : {
      alias?: string;
      filtering?:
        | boolean
        | Partial<
            Record<
              GetNexusPrismaInput<ModelName, MethodName, 'filtering'>,
              boolean
            >
          >;
      ordering?:
        | boolean
        | Partial<
            Record<
              GetNexusPrismaInput<ModelName, MethodName, 'ordering'>,
              boolean
            >
          >;
      pagination?: boolean | Pagination;
    } & DynamicRequiredType<ReturnType>;

type IsScalar<TypeName extends any> = TypeName extends core.GetGen<
  'scalarNames'
>
  ? true
  : false;

type NexusPrismaFields<ModelName extends keyof NexusPrismaTypes> = {
  [MethodName in keyof NexusPrismaTypes[ModelName]]: NexusPrismaMethod<
    ModelName,
    MethodName,
    IsScalar<NexusPrismaTypes[ModelName][MethodName]> // Is the return type a scalar?
  >;
};

type NexusPrismaMethod<
  ModelName extends keyof NexusPrismaTypes,
  MethodName extends keyof NexusPrismaTypes[ModelName],
  IsScalar extends boolean,
  ReturnType extends any = NexusPrismaTypes[ModelName][MethodName]
> = IsScalar extends true // If scalar
  ? (opts?: NexusPrismaScalarOpts) => NexusPrismaFields<ModelName> // Return optional scalar opts
  : ModelNameExistsInGraphQLType<ReturnType> extends true // If model name has a mapped graphql types
  ? (
      opts?: NexusPrismaRelationOpts<ModelName, MethodName, ReturnType>
    ) => NexusPrismaFields<ModelName> // Then make opts optional
  : (
      opts: NexusPrismaRelationOpts<ModelName, MethodName, ReturnType>
    ) => NexusPrismaFields<ModelName>; // Else force use input the related graphql type -> { type: '...' }

type GetNexusPrismaMethod<
  TypeName extends string
> = TypeName extends keyof NexusPrismaMethods
  ? NexusPrismaMethods[TypeName]
  : <CustomTypeName extends keyof ModelTypes>(
      typeName: CustomTypeName
    ) => NexusPrismaMethods[CustomTypeName];

type GetNexusPrisma<
  TypeName extends string,
  ModelOrCrud extends 'model' | 'crud'
> = ModelOrCrud extends 'model'
  ? TypeName extends 'Mutation'
    ? never
    : TypeName extends 'Query'
    ? never
    : GetNexusPrismaMethod<TypeName>
  : ModelOrCrud extends 'crud'
  ? TypeName extends 'Mutation'
    ? GetNexusPrismaMethod<TypeName>
    : TypeName extends 'Query'
    ? GetNexusPrismaMethod<TypeName>
    : never
  : never;
  

// Generated
interface ModelTypes {
  A: photon.A
}
  
interface NexusPrismaInputs {
  Query: {
    as: {
  filtering: 'id' | 'AND' | 'OR' | 'NOT'
  ordering: 'id'
}

  },
    A: {


  }
}

interface NexusPrismaTypes {
  Query: {
    as: 'A'
    a: 'A'

  },
  Mutation: {
    createOneA: 'A'
    deleteOneA: 'A'
    updateOneA: 'A'
    updateManyA: 'BatchPayload'
    deleteManyA: 'BatchPayload'

  },
  A: {
    id: 'Int'

}
}

interface NexusPrismaMethods {
  A: NexusPrismaFields<'A'>
  Query: NexusPrismaFields<'Query'>
  Mutation: NexusPrismaFields<'Mutation'>
}
  

declare global {
  type NexusPrisma<
    TypeName extends string,
    ModelOrCrud extends 'model' | 'crud'
  > = GetNexusPrisma<TypeName, ModelOrCrud>;
}
  "
`;

exports[`integrates together: photon source code 1`] = `
"\\"use strict\\";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
const runtime_1 = require(\\"./runtime\\");
/**
 * Query Engine version: latest
 */
const path = require(\\"path\\");
const debug = runtime_1.debugLib('photon');
class PhotonFetcher {
    constructor(photon, engine, debug = false, hooks) {
        this.photon = photon;
        this.engine = engine;
        this.debug = debug;
        this.hooks = hooks;
    }
    request(document, path = [], rootField, typeName, isList, callsite) {
        return __awaiter(this, void 0, void 0, function* () {
            const query = String(document);
            debug('Request:');
            debug(query);
            if (this.hooks && this.hooks.beforeRequest) {
                this.hooks.beforeRequest({ query, path, rootField, typeName, document });
            }
            try {
                yield this.photon.connect();
                const result = yield this.engine.request(query, typeName);
                debug('Response:');
                debug(result);
                return this.unpack(result, path, rootField, isList);
            }
            catch (e) {
                if (callsite) {
                    const { stack } = runtime_1.printStack({
                        callsite,
                        originalMethod: path.join('.'),
                        onUs: e.isPanic
                    });
                    throw new Error(stack + '\\\\n\\\\n' + e.message);
                }
                else {
                    if (e.isPanic) {
                        throw e;
                    }
                    else {
                        throw new Error(\`Error in Photon\${path}: \\\\n\` + e.stack);
                    }
                }
            }
        });
    }
    unpack(data, path, rootField, isList) {
        const getPath = [];
        if (rootField) {
            getPath.push(rootField);
        }
        getPath.push(...path.filter(p => p !== 'select' && p !== 'include'));
        const result = runtime_1.deepGet(data, getPath) || null;
        if (result === null && isList) {
            return [];
        }
        return result;
    }
}
/**
 * Build tool annotations
 * In order to make \`ncc\` and \`node-file-trace\` happy.
**/
path.join(__dirname, 'runtime/__STRIPPED__');
class Photon {
    constructor(options = {}) {
        const useDebug = options.debug === true ? true : typeof options.debug === 'object' ? Boolean(options.debug.library) : false;
        if (useDebug) {
            runtime_1.debugLib.enable('photon');
        }
        const debugEngine = options.debug === true ? true : typeof options.debug === 'object' ? Boolean(options.debug.engine) : false;
        // datamodel = datamodel without datasources + printed datasources
        this.datamodel = \\"generator photonjs {\\\\n  provider = \\\\\\"photonjs\\\\\\"\\\\n  output   = \\\\\\"../../node_modules/@generated/photon\\\\\\"\\\\n}\\\\n\\\\nmodel A {\\\\n  id Int @id\\\\n}\\\\n\\";
        const predefinedDatasources = [];
        const inputDatasources = Object.entries(options.datasources || {}).map(([name, url]) => ({ name, url: url }));
        const datasources = runtime_1.mergeBy(predefinedDatasources, inputDatasources, (source) => source.name);
        const internal = options.__internal || {};
        const engineConfig = internal.engine || {};
        this.engine = new runtime_1.Engine({
            cwd: engineConfig.cwd || path.resolve(__dirname, \\"../../../tests/integration\\"),
            debug: debugEngine,
            datamodel: this.datamodel,
            prismaPath: engineConfig.binaryPath || undefined,
            datasources,
            generator: { \\"name\\": \\"photonjs\\", \\"provider\\": \\"photonjs\\", \\"output\\": \\"__STRIPPED__\\" \\"platforms\\": [], \\"pinnedPlatform\\": null, \\"config\\": {} },
            platform: undefined
        });
        this.dmmf = new runtime_1.DMMFClass(exports.dmmf);
        this.fetcher = new PhotonFetcher(this, this.engine, false, internal.hooks);
    }
    connectEngine(publicCall) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.engine.start();
        });
    }
    connect() {
        if (this.connectionPromise) {
            return this.connectionPromise;
        }
        this.connectionPromise = this.connectEngine(true);
        return this.connectionPromise;
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.engine.stop();
        });
    }
    // won't be generated for now
    // private _query?: QueryDelegate
    // get query(): QueryDelegate {
    //   return this._query ? this._query: (this._query = QueryDelegate(this.dmmf, this.fetcher))
    // }
    get as() {
        return ADelegate(this.dmmf, this.fetcher);
    }
}
exports.default = Photon;
/**
 * Enums
 */
// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275
function makeEnum(x) { return x; }
exports.OrderByArg = makeEnum({
    asc: 'asc',
    desc: 'desc'
});
function ADelegate(dmmf, fetcher) {
    const A = (args) => new AClient(dmmf, fetcher, 'query', 'findManyA', 'as', args, []);
    A.findOne = (args) => args.select ? new AClient(dmmf, fetcher, 'query', 'findOneA', 'as.findOne', args, []) : new AClient(dmmf, fetcher, 'query', 'findOneA', 'as.findOne', args, []);
    A.findMany = (args) => new AClient(dmmf, fetcher, 'query', 'findManyA', 'as.findMany', args, []);
    A.create = (args) => args.select ? new AClient(dmmf, fetcher, 'mutation', 'createOneA', 'as.create', args, []) : new AClient(dmmf, fetcher, 'mutation', 'createOneA', 'as.create', args, []);
    A.delete = (args) => args.select ? new AClient(dmmf, fetcher, 'mutation', 'deleteOneA', 'as.delete', args, []) : new AClient(dmmf, fetcher, 'mutation', 'deleteOneA', 'as.delete', args, []);
    A.update = (args) => args.select ? new AClient(dmmf, fetcher, 'mutation', 'updateOneA', 'as.update', args, []) : new AClient(dmmf, fetcher, 'mutation', 'updateOneA', 'as.update', args, []);
    A.deleteMany = (args) => new AClient(dmmf, fetcher, 'mutation', 'deleteManyA', 'as.deleteMany', args, []);
    A.updateMany = (args) => new AClient(dmmf, fetcher, 'mutation', 'updateManyA', 'as.updateMany', args, []);
    A.count = () => new AClient(dmmf, fetcher, 'query', 'aggregateA', 'as.count', {}, ['count']);
    return A; // any needed until https://github.com/microsoft/TypeScript/issues/31335 is resolved
}
class AClient {
    constructor(_dmmf, _fetcher, _queryType, _rootField, _clientMethod, _args, _path, _isList = false) {
        this._dmmf = _dmmf;
        this._fetcher = _fetcher;
        this._queryType = _queryType;
        this._rootField = _rootField;
        this._clientMethod = _clientMethod;
        this._args = _args;
        this._path = _path;
        this._isList = _isList;
        // @ts-ignore
        if (typeof window === 'undefined' && process.env.NODE_ENV !== 'production') {
            const error = new Error();
            if (error && error.stack) {
                const stack = error.stack;
                this._callsite = stack;
            }
        }
    }
    get _document() {
        const { _rootField: rootField } = this;
        const document = runtime_1.makeDocument({
            dmmf: this._dmmf,
            rootField,
            rootTypeName: this._queryType,
            select: this._args
        });
        try {
            document.validate(this._args, false, this._clientMethod);
        }
        catch (e) {
            const x = e;
            if (x.render) {
                if (this._callsite) {
                    e.message = x.render(this._callsite);
                }
            }
            throw e;
        }
        return runtime_1.transformDocument(document);
    }
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then(onfulfilled, onrejected) {
        if (!this._requestPromise) {
            this._requestPromise = this._fetcher.request(this._document, this._path, this._rootField, 'A', this._isList, this._callsite);
        }
        return this._requestPromise.then(onfulfilled, onrejected);
    }
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch(onrejected) {
        if (!this._requestPromise) {
            this._requestPromise = this._fetcher.request(this._document, this._path, this._rootField, 'A', this._isList, this._callsite);
        }
        return this._requestPromise.catch(onrejected);
    }
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally) {
        if (!this._requestPromise) {
            this._requestPromise = this._fetcher.request(this._document, this._path, this._rootField, 'A', this._isList, this._callsite);
        }
        return this._requestPromise.finally(onfinally);
    }
}
exports.AClient = AClient;
/**
 * DMMF
 */
exports.dmmf = { \\"datamodel\\": { \\"enums\\": [], \\"models\\": [{ \\"name\\": \\"A\\", \\"isEmbedded\\": false, \\"dbName\\": null, \\"fields\\": [{ \\"name\\": \\"id\\", \\"kind\\": \\"scalar\\", \\"dbName\\": null, \\"isList\\": false, \\"isRequired\\": true, \\"isUnique\\": false, \\"isId\\": true, \\"type\\": \\"Int\\", \\"isGenerated\\": false, \\"isUpdatedAt\\": false }], \\"isGenerated\\": false }] }, \\"mappings\\": [{ \\"model\\": \\"A\\", \\"plural\\": \\"as\\", \\"findOne\\": \\"findOneA\\", \\"findMany\\": \\"findManyA\\", \\"create\\": \\"createOneA\\", \\"delete\\": \\"deleteOneA\\", \\"update\\": \\"updateOneA\\", \\"deleteMany\\": \\"deleteManyA\\", \\"updateMany\\": \\"updateManyA\\", \\"aggregate\\": \\"aggregateA\\" }], \\"schema\\": { \\"enums\\": [{ \\"name\\": \\"OrderByArg\\", \\"values\\": [\\"asc\\", \\"desc\\"] }], \\"outputTypes\\": [{ \\"name\\": \\"A\\", \\"fields\\": [{ \\"name\\": \\"id\\", \\"args\\": [], \\"outputType\\": { \\"type\\": \\"Int\\", \\"kind\\": \\"scalar\\", \\"isRequired\\": true, \\"isList\\": false } }] }, { \\"name\\": \\"AggregateA\\", \\"fields\\": [{ \\"name\\": \\"count\\", \\"args\\": [], \\"outputType\\": { \\"type\\": \\"Int\\", \\"kind\\": \\"scalar\\", \\"isRequired\\": true, \\"isList\\": false } }] }, { \\"name\\": \\"Query\\", \\"fields\\": [{ \\"name\\": \\"findManyA\\", \\"args\\": [{ \\"name\\": \\"where\\", \\"inputType\\": [{ \\"type\\": \\"AWhereInput\\", \\"kind\\": \\"object\\", \\"isRequired\\": false, \\"isList\\": false }] }, { \\"name\\": \\"orderBy\\", \\"inputType\\": [{ \\"isList\\": false, \\"isRequired\\": false, \\"type\\": \\"AOrderByInput\\", \\"kind\\": \\"object\\" }] }, { \\"name\\": \\"skip\\", \\"inputType\\": [{ \\"type\\": \\"Int\\", \\"kind\\": \\"scalar\\", \\"isRequired\\": false, \\"isList\\": false }] }, { \\"name\\": \\"after\\", \\"inputType\\": [{ \\"type\\": \\"String\\", \\"kind\\": \\"scalar\\", \\"isRequired\\": false, \\"isList\\": false }] }, { \\"name\\": \\"before\\", \\"inputType\\": [{ \\"type\\": \\"String\\", \\"kind\\": \\"scalar\\", \\"isRequired\\": false, \\"isList\\": false }] }, { \\"name\\": \\"first\\", \\"inputType\\": [{ \\"type\\": \\"Int\\", \\"kind\\": \\"scalar\\", \\"isRequired\\": false, \\"isList\\": false }] }, { \\"name\\": \\"last\\", \\"inputType\\": [{ \\"type\\": \\"Int\\", \\"kind\\": \\"scalar\\", \\"isRequired\\": false, \\"isList\\": false }] }], \\"outputType\\": { \\"type\\": \\"A\\", \\"kind\\": \\"object\\", \\"isRequired\\": false, \\"isList\\": true } }, { \\"name\\": \\"aggregateA\\", \\"args\\": [], \\"outputType\\": { \\"type\\": \\"AggregateA\\", \\"kind\\": \\"object\\", \\"isRequired\\": true, \\"isList\\": false } }, { \\"name\\": \\"findOneA\\", \\"args\\": [{ \\"name\\": \\"where\\", \\"inputType\\": [{ \\"type\\": \\"AWhereUniqueInput\\", \\"kind\\": \\"object\\", \\"isRequired\\": true, \\"isList\\": false }] }], \\"outputType\\": { \\"type\\": \\"A\\", \\"kind\\": \\"object\\", \\"isRequired\\": false, \\"isList\\": false } }] }, { \\"name\\": \\"BatchPayload\\", \\"fields\\": [{ \\"name\\": \\"count\\", \\"args\\": [], \\"outputType\\": { \\"type\\": \\"Int\\", \\"kind\\": \\"scalar\\", \\"isRequired\\": true, \\"isList\\": false } }] }, { \\"name\\": \\"Mutation\\", \\"fields\\": [{ \\"name\\": \\"createOneA\\", \\"args\\": [], \\"outputType\\": { \\"type\\": \\"A\\", \\"kind\\": \\"object\\", \\"isRequired\\": true, \\"isList\\": false } }, { \\"name\\": \\"deleteOneA\\", \\"args\\": [{ \\"name\\": \\"where\\", \\"inputType\\": [{ \\"type\\": \\"AWhereUniqueInput\\", \\"kind\\": \\"object\\", \\"isRequired\\": true, \\"isList\\": false }] }], \\"outputType\\": { \\"type\\": \\"A\\", \\"kind\\": \\"object\\", \\"isRequired\\": false, \\"isList\\": false } }, { \\"name\\": \\"updateOneA\\", \\"args\\": [{ \\"name\\": \\"data\\", \\"inputType\\": [{ \\"type\\": \\"AUpdateInput\\", \\"kind\\": \\"object\\", \\"isRequired\\": true, \\"isList\\": false }] }, { \\"name\\": \\"where\\", \\"inputType\\": [{ \\"type\\": \\"AWhereUniqueInput\\", \\"kind\\": \\"object\\", \\"isRequired\\": true, \\"isList\\": false }] }], \\"outputType\\": { \\"type\\": \\"A\\", \\"kind\\": \\"object\\", \\"isRequired\\": false, \\"isList\\": false } }, { \\"name\\": \\"updateManyA\\", \\"args\\": [{ \\"name\\": \\"data\\", \\"inputType\\": [{ \\"type\\": \\"AUpdateManyMutationInput\\", \\"kind\\": \\"object\\", \\"isRequired\\": true, \\"isList\\": false }] }, { \\"name\\": \\"where\\", \\"inputType\\": [{ \\"type\\": \\"AWhereInput\\", \\"kind\\": \\"object\\", \\"isRequired\\": false, \\"isList\\": false }] }], \\"outputType\\": { \\"type\\": \\"BatchPayload\\", \\"kind\\": \\"object\\", \\"isRequired\\": true, \\"isList\\": false } }, { \\"name\\": \\"deleteManyA\\", \\"args\\": [{ \\"name\\": \\"where\\", \\"inputType\\": [{ \\"type\\": \\"AWhereInput\\", \\"kind\\": \\"object\\", \\"isRequired\\": false, \\"isList\\": false }] }], \\"outputType\\": { \\"type\\": \\"BatchPayload\\", \\"kind\\": \\"object\\", \\"isRequired\\": true, \\"isList\\": false } }] }], \\"inputTypes\\": [{ \\"name\\": \\"AWhereInput\\", \\"fields\\": [{ \\"name\\": \\"id\\", \\"inputType\\": [{ \\"isList\\": false, \\"isRequired\\": false, \\"kind\\": \\"scalar\\", \\"type\\": \\"Int\\" }, { \\"type\\": \\"IntFilter\\", \\"isList\\": false, \\"isRequired\\": false, \\"kind\\": \\"object\\" }], \\"isRelationFilter\\": false }, { \\"name\\": \\"AND\\", \\"inputType\\": [{ \\"type\\": \\"AWhereInput\\", \\"kind\\": \\"object\\", \\"isRequired\\": false, \\"isList\\": true }], \\"isRelationFilter\\": true }, { \\"name\\": \\"OR\\", \\"inputType\\": [{ \\"type\\": \\"AWhereInput\\", \\"kind\\": \\"object\\", \\"isRequired\\": false, \\"isList\\": true }], \\"isRelationFilter\\": true }, { \\"name\\": \\"NOT\\", \\"inputType\\": [{ \\"type\\": \\"AWhereInput\\", \\"kind\\": \\"object\\", \\"isRequired\\": false, \\"isList\\": true }], \\"isRelationFilter\\": true }], \\"isWhereType\\": true, \\"atLeastOne\\": false }, { \\"name\\": \\"AWhereUniqueInput\\", \\"fields\\": [{ \\"name\\": \\"id\\", \\"inputType\\": [{ \\"type\\": \\"Int\\", \\"kind\\": \\"scalar\\", \\"isRequired\\": false, \\"isList\\": false }] }], \\"atLeastOne\\": true }, { \\"name\\": \\"AUpdateInput\\", \\"fields\\": [{ \\"name\\": \\"id\\", \\"inputType\\": [{ \\"type\\": \\"Int\\", \\"kind\\": \\"scalar\\", \\"isRequired\\": false, \\"isList\\": false }] }] }, { \\"name\\": \\"AUpdateManyMutationInput\\", \\"fields\\": [{ \\"name\\": \\"id\\", \\"inputType\\": [{ \\"type\\": \\"Int\\", \\"kind\\": \\"scalar\\", \\"isRequired\\": false, \\"isList\\": false }] }] }, { \\"name\\": \\"IntFilter\\", \\"fields\\": [{ \\"name\\": \\"equals\\", \\"inputType\\": [{ \\"isList\\": false, \\"isRequired\\": false, \\"kind\\": \\"scalar\\", \\"type\\": \\"Int\\" }] }, { \\"name\\": \\"not\\", \\"inputType\\": [{ \\"isList\\": false, \\"isRequired\\": false, \\"kind\\": \\"scalar\\", \\"type\\": \\"Int\\" }, { \\"isList\\": false, \\"isRequired\\": false, \\"kind\\": \\"scalar\\", \\"type\\": \\"IntFilter\\" }] }, { \\"name\\": \\"in\\", \\"inputType\\": [{ \\"isList\\": true, \\"isRequired\\": false, \\"kind\\": \\"scalar\\", \\"type\\": \\"Int\\" }] }, { \\"name\\": \\"notIn\\", \\"inputType\\": [{ \\"isList\\": true, \\"isRequired\\": false, \\"kind\\": \\"scalar\\", \\"type\\": \\"Int\\" }] }, { \\"name\\": \\"lt\\", \\"inputType\\": [{ \\"isList\\": false, \\"isRequired\\": false, \\"kind\\": \\"scalar\\", \\"type\\": \\"Int\\" }] }, { \\"name\\": \\"lte\\", \\"inputType\\": [{ \\"isList\\": false, \\"isRequired\\": false, \\"kind\\": \\"scalar\\", \\"type\\": \\"Int\\" }] }, { \\"name\\": \\"gt\\", \\"inputType\\": [{ \\"isList\\": false, \\"isRequired\\": false, \\"kind\\": \\"scalar\\", \\"type\\": \\"Int\\" }] }, { \\"name\\": \\"gte\\", \\"inputType\\": [{ \\"isList\\": false, \\"isRequired\\": false, \\"kind\\": \\"scalar\\", \\"type\\": \\"Int\\" }] }], \\"atLeastOne\\": false }, { \\"name\\": \\"AOrderByInput\\", \\"atLeastOne\\": true, \\"atMostOne\\": true, \\"isOrderType\\": true, \\"fields\\": [{ \\"name\\": \\"id\\", \\"inputType\\": [{ \\"type\\": \\"OrderByArg\\", \\"isList\\": false, \\"isRequired\\": false, \\"kind\\": \\"enum\\" }], \\"isRelationFilter\\": false }] }] } };

module.exports = Photon; // needed to support const Photon = require('...') in js
Object.defineProperty(module.exports, \\"__esModule\\", { value: true });
for (let key in exports) {
  if (exports.hasOwnProperty(key)) {
    module.exports[key] = exports[key];
  }
}"
`;

exports[`integrates together: photon typescript declaration 1`] = `
"import { DMMF, DMMFClass, Engine } from './runtime';
/**
 * Utility Types
 */
export declare type Enumerable<T> = T | Array<T>;
export declare type MergeTruthyValues<R extends object, S extends object> = {
    [key in keyof S | keyof R]: key extends false ? never : key extends keyof S ? S[key] extends false ? never : S[key] : key extends keyof R ? R[key] : never;
};
export declare type CleanupNever<T> = {
    [key in keyof T]: T[key] extends never ? never : key;
}[keyof T];
/**
 * Subset
 * @desc From \`T\` pick properties that exist in \`U\`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PhotonFetcher {
    private readonly photon;
    private readonly engine;
    private readonly debug;
    private readonly hooks?;
    constructor(photon: Photon, engine: Engine, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, path?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    protected unpack(data: any, path: string[], rootField?: string, isList?: boolean): any;
}
/**
 * Client
**/
export declare type Datasources = {};
export interface PhotonOptions {
    datasources?: Datasources;
    debug?: boolean | {
        engine?: boolean;
        library?: boolean;
    };
    /**
     * You probably don't want to use this. \`__internal\` is used by internal tooling.
     */
    __internal?: {
        hooks?: Hooks;
        engine?: {
            cwd?: string;
            binaryPath?: string;
        };
    };
}
export declare type Hooks = {
    beforeRequest?: (options: {
        query: string;
        path: string[];
        rootField?: string;
        typeName?: string;
        document: any;
    }) => any;
};
export default class Photon {
    private fetcher;
    private readonly dmmf;
    private readonly engine;
    private readonly datamodel;
    private connectionPromise?;
    constructor(options?: PhotonOptions);
    private connectEngine;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    readonly as: ADelegate;
}
export declare const OrderByArg: {
    asc: \\"asc\\";
    desc: \\"desc\\";
};
export declare type OrderByArg = (typeof OrderByArg)[keyof typeof OrderByArg];
/**
 * Model A
 */
export declare type A = {
    id: number;
};
export declare type AScalars = 'id';
export declare type ASelect = {
    id?: boolean;
};
export declare type AInclude = {};
declare type ADefault = {
    id: true;
};
declare type AGetSelectPayload<S extends boolean | ASelect> = S extends true ? A : S extends ASelect ? {
    [P in CleanupNever<MergeTruthyValues<{}, S>>]: P extends AScalars ? A[P] : never;
} : never;
declare type AGetIncludePayload<S extends boolean | AInclude> = S extends true ? A : S extends AInclude ? {
    [P in CleanupNever<MergeTruthyValues<ADefault, S>>]: P extends AScalars ? A[P] : never;
} : never;
export interface ADelegate {
    <T extends FindManyAArgs>(args?: Subset<T, FindManyAArgs>): T extends FindManyAArgsRequired ? 'Please either choose \`select\` or \`include\`' : T extends FindManyASelectArgs ? Promise<Array<AGetSelectPayload<ExtractFindManyASelectArgs<T>>>> : T extends FindManyAIncludeArgs ? Promise<Array<AGetIncludePayload<ExtractFindManyAIncludeArgs<T>>>> : Promise<Array<A>>;
    findOne<T extends FindOneAArgs>(args: Subset<T, FindOneAArgs>): T extends FindOneAArgsRequired ? 'Please either choose \`select\` or \`include\`' : T extends FindOneASelectArgs ? Promise<AGetSelectPayload<ExtractFindOneASelectArgs<T>>> : T extends FindOneAIncludeArgs ? Promise<AGetIncludePayload<ExtractFindOneAIncludeArgs<T>>> : AClient<A>;
    findMany<T extends FindManyAArgs>(args?: Subset<T, FindManyAArgs>): T extends FindManyAArgsRequired ? 'Please either choose \`select\` or \`include\`' : T extends FindManyASelectArgs ? Promise<Array<AGetSelectPayload<ExtractFindManyASelectArgs<T>>>> : T extends FindManyAIncludeArgs ? Promise<Array<AGetIncludePayload<ExtractFindManyAIncludeArgs<T>>>> : Promise<Array<A>>;
    create<T extends ACreateArgs>(args: Subset<T, ACreateArgs>): T extends ACreateArgsRequired ? 'Please either choose \`select\` or \`include\`' : T extends ASelectCreateArgs ? Promise<AGetSelectPayload<ExtractASelectCreateArgs<T>>> : T extends AIncludeCreateArgs ? Promise<AGetIncludePayload<ExtractAIncludeCreateArgs<T>>> : AClient<A>;
    delete<T extends ADeleteArgs>(args: Subset<T, ADeleteArgs>): T extends ADeleteArgsRequired ? 'Please either choose \`select\` or \`include\`' : T extends ASelectDeleteArgs ? Promise<AGetSelectPayload<ExtractASelectDeleteArgs<T>>> : T extends AIncludeDeleteArgs ? Promise<AGetIncludePayload<ExtractAIncludeDeleteArgs<T>>> : AClient<A>;
    update<T extends AUpdateArgs>(args: Subset<T, AUpdateArgs>): T extends AUpdateArgsRequired ? 'Please either choose \`select\` or \`include\`' : T extends ASelectUpdateArgs ? Promise<AGetSelectPayload<ExtractASelectUpdateArgs<T>>> : T extends AIncludeUpdateArgs ? Promise<AGetIncludePayload<ExtractAIncludeUpdateArgs<T>>> : AClient<A>;
    deleteMany<T extends ADeleteManyArgs>(args: Subset<T, ADeleteManyArgs>): Promise<BatchPayload>;
    updateMany<T extends AUpdateManyArgs>(args: Subset<T, AUpdateManyArgs>): Promise<BatchPayload>;
    count(): Promise<number>;
}
export declare class AClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _path;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: DMMFClass, _fetcher: PhotonFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _path: string[], _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PhotonPromise';
    private readonly _document;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}
/**
 * A findOne
 */
export declare type FindOneAArgs = {
    select?: ASelect | null;
    include?: AInclude | null;
    where: AWhereUniqueInput;
};
export declare type FindOneAArgsRequired = {
    select: ASelect;
    include: AInclude;
    where: AWhereUniqueInput;
};
export declare type FindOneASelectArgs = {
    select: ASelect;
    where: AWhereUniqueInput;
};
export declare type FindOneASelectArgsOptional = {
    select?: ASelect | null;
    where: AWhereUniqueInput;
};
export declare type FindOneAIncludeArgs = {
    include: AInclude;
    where: AWhereUniqueInput;
};
export declare type FindOneAIncludeArgsOptional = {
    include?: AInclude | null;
    where: AWhereUniqueInput;
};
export declare type ExtractFindOneASelectArgs<S extends undefined | boolean | FindOneASelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneASelectArgs ? S['select'] : true;
export declare type ExtractFindOneAIncludeArgs<S extends undefined | boolean | FindOneAIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneAIncludeArgs ? S['include'] : true;
/**
 * A findMany
 */
export declare type FindManyAArgs = {
    select?: ASelect | null;
    include?: AInclude | null;
    where?: AWhereInput | null;
    orderBy?: AOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyAArgsRequired = {
    select: ASelect;
    include: AInclude;
    where?: AWhereInput | null;
    orderBy?: AOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyASelectArgs = {
    select: ASelect;
    where?: AWhereInput | null;
    orderBy?: AOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyASelectArgsOptional = {
    select?: ASelect | null;
    where?: AWhereInput | null;
    orderBy?: AOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyAIncludeArgs = {
    include: AInclude;
    where?: AWhereInput | null;
    orderBy?: AOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyAIncludeArgsOptional = {
    include?: AInclude | null;
    where?: AWhereInput | null;
    orderBy?: AOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type ExtractFindManyASelectArgs<S extends undefined | boolean | FindManyASelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyASelectArgs ? S['select'] : true;
export declare type ExtractFindManyAIncludeArgs<S extends undefined | boolean | FindManyAIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyAIncludeArgs ? S['include'] : true;
/**
 * A create
 */
export declare type ACreateArgs = {
    select?: ASelect | null;
    include?: AInclude | null;
};
export declare type ACreateArgsRequired = {
    select: ASelect;
    include: AInclude;
};
export declare type ASelectCreateArgs = {
    select: ASelect;
};
export declare type ASelectCreateArgsOptional = {
    select?: ASelect | null;
};
export declare type AIncludeCreateArgs = {
    include: AInclude;
};
export declare type AIncludeCreateArgsOptional = {
    include?: AInclude | null;
};
export declare type ExtractASelectCreateArgs<S extends undefined | boolean | ASelectCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ASelectCreateArgs ? S['select'] : true;
export declare type ExtractAIncludeCreateArgs<S extends undefined | boolean | AIncludeCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends AIncludeCreateArgs ? S['include'] : true;
/**
 * A update
 */
export declare type AUpdateArgs = {
    select?: ASelect | null;
    include?: AInclude | null;
    data: AUpdateInput;
    where: AWhereUniqueInput;
};
export declare type AUpdateArgsRequired = {
    select: ASelect;
    include: AInclude;
    data: AUpdateInput;
    where: AWhereUniqueInput;
};
export declare type ASelectUpdateArgs = {
    select: ASelect;
    data: AUpdateInput;
    where: AWhereUniqueInput;
};
export declare type ASelectUpdateArgsOptional = {
    select?: ASelect | null;
    data: AUpdateInput;
    where: AWhereUniqueInput;
};
export declare type AIncludeUpdateArgs = {
    include: AInclude;
    data: AUpdateInput;
    where: AWhereUniqueInput;
};
export declare type AIncludeUpdateArgsOptional = {
    include?: AInclude | null;
    data: AUpdateInput;
    where: AWhereUniqueInput;
};
export declare type ExtractASelectUpdateArgs<S extends undefined | boolean | ASelectUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ASelectUpdateArgs ? S['select'] : true;
export declare type ExtractAIncludeUpdateArgs<S extends undefined | boolean | AIncludeUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends AIncludeUpdateArgs ? S['include'] : true;
/**
 * A updateMany
 */
export declare type AUpdateManyArgs = {
    data: AUpdateManyMutationInput;
    where?: AWhereInput | null;
};
/**
 * A delete
 */
export declare type ADeleteArgs = {
    select?: ASelect | null;
    include?: AInclude | null;
    where: AWhereUniqueInput;
};
export declare type ADeleteArgsRequired = {
    select: ASelect;
    include: AInclude;
    where: AWhereUniqueInput;
};
export declare type ASelectDeleteArgs = {
    select: ASelect;
    where: AWhereUniqueInput;
};
export declare type ASelectDeleteArgsOptional = {
    select?: ASelect | null;
    where: AWhereUniqueInput;
};
export declare type AIncludeDeleteArgs = {
    include: AInclude;
    where: AWhereUniqueInput;
};
export declare type AIncludeDeleteArgsOptional = {
    include?: AInclude | null;
    where: AWhereUniqueInput;
};
export declare type ExtractASelectDeleteArgs<S extends undefined | boolean | ASelectDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ASelectDeleteArgs ? S['select'] : true;
export declare type ExtractAIncludeDeleteArgs<S extends undefined | boolean | AIncludeDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends AIncludeDeleteArgs ? S['include'] : true;
/**
 * A deleteMany
 */
export declare type ADeleteManyArgs = {
    where?: AWhereInput | null;
};
/**
 * A without action
 */
export declare type AArgs = {
    select?: ASelect | null;
    include?: AInclude | null;
};
export declare type AArgsRequired = {
    select: ASelect;
    include: AInclude;
};
export declare type ASelectArgs = {
    select: ASelect;
};
export declare type ASelectArgsOptional = {
    select?: ASelect | null;
};
export declare type AIncludeArgs = {
    include: AInclude;
};
export declare type AIncludeArgsOptional = {
    include?: AInclude | null;
};
export declare type ExtractASelectArgs<S extends undefined | boolean | ASelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ASelectArgs ? S['select'] : true;
export declare type ExtractAIncludeArgs<S extends undefined | boolean | AIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends AIncludeArgs ? S['include'] : true;
/**
 * Deep Input Types
 */
export declare type AWhereInput = {
    id?: number | IntFilter | null;
    AND?: Enumerable<AWhereInput>;
    OR?: Enumerable<AWhereInput>;
    NOT?: Enumerable<AWhereInput>;
};
export declare type AWhereUniqueInput = {
    id?: number | null;
};
export declare type AUpdateInput = {
    id?: number | null;
};
export declare type AUpdateManyMutationInput = {
    id?: number | null;
};
export declare type IntFilter = {
    equals?: number | null;
    not?: number | IntFilter | null;
    in?: Enumerable<number>;
    notIn?: Enumerable<number>;
    lt?: number | null;
    lte?: number | null;
    gt?: number | null;
    gte?: number | null;
};
export declare type AOrderByInput = {
    id?: OrderByArg | null;
};
/**
 * Batch Payload for updateMany & deleteMany
 */
export declare type BatchPayload = {
    count: number;
};
/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
"
`;
